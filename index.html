<!-- LOCAL_FILE_PATH: /mnt/data/WhatsApp Image 2025-11-20 at 14.07.34_b9daf329.jpg -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
<title>Software Architecture — Exam Notes</title>
<style>
    :root {
        --bg-core: #000000;
        --bg-surface: #0a0a0a;
        --bg-card: #111111;
        --text-main: #e0e0e0;
        --text-muted: #a0a0a0;
        --accent: #ffffff;
        --border: #333333;
        --success: #00ff9d;
        --warning: #ffcc00;
        --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --font-mono: "Menlo", "Consolas", "Monaco", "Liberation Mono", "Lucida Console", monospace;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

    body {
        background-color: var(--bg-core);
        color: var(--text-main);
        font-family: var(--font-main);
        line-height: 1.6;
        font-size: 16px;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        overflow-x: hidden;
    }

    /* UTILS */
    .hidden { display: none !important; }
    strong { color: var(--accent); font-weight: 700; }
    .highlight { color: var(--success); }
    
    /* HEADER */
    header {
        position: sticky;
        top: 0;
        z-index: 1000;
        background: rgba(0,0,0,0.95);
        border-bottom: 1px solid var(--border);
        padding: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        backdrop-filter: blur(5px);
    }
    .logo { font-weight: 800; font-size: 1.2rem; color: var(--accent); letter-spacing: -0.5px; }
    .logo span { color: var(--text-muted); font-weight: 400; font-size: 0.8rem; margin-left: 8px; border: 1px solid var(--border); padding: 2px 6px; border-radius: 4px; }

    .menu-toggle {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--accent);
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 600;
    }

    /* SIDEBAR MENU */
    #sidebar {
        position: fixed;
        top: 0; right: -300px;
        width: 300px;
        height: 100vh;
        background: var(--bg-surface);
        border-left: 1px solid var(--border);
        z-index: 2000;
        transition: 0.3s ease;
        padding: 2rem 1rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }
    #sidebar.active { right: 0; }
    
    .close-btn { position: absolute; top: 1rem; right: 1rem; background: none; border: none; color: var(--text-muted); font-size: 1.5rem; cursor: pointer; }
    
    .menu-section h4 { color: var(--text-muted); text-transform: uppercase; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 1px; }
    
    .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
    
    button.action-btn {
        background: var(--bg-card);
        border: 1px solid var(--border);
        color: var(--text-main);
        padding: 0.75rem;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        text-align: center;
        transition: 0.2s;
    }
    button.action-btn:hover { background: var(--border); }
    button.action-btn.active { background: var(--accent); color: #000; font-weight: bold; border-color: var(--accent); }

    #search-box {
        width: 100%;
        padding: 0.8rem;
        background: var(--bg-core);
        border: 1px solid var(--border);
        color: var(--text-main);
        border-radius: 6px;
        margin-bottom: 1rem;
    }

    .toc-link { display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none; border-bottom: 1px solid #222; font-size: 0.9rem; }
    .toc-link:hover { color: var(--accent); padding-left: 5px; transition: 0.2s; }

    /* MAIN CONTENT */
    main { padding: 1rem; max-width: 900px; margin: 0 auto; padding-bottom: 4rem; }

    /* QUESTION CARD */
    .q-card {
        border-bottom: 4px solid var(--border);
        padding-bottom: 3rem;
        margin-bottom: 3rem;
    }
    
    h2 { font-size: 1.4rem; color: var(--accent); margin: 2rem 0 1rem; line-height: 1.3; }
    h3 { font-size: 1.1rem; color: var(--text-main); margin: 1.5rem 0 0.5rem; border-left: 3px solid var(--text-muted); padding-left: 0.8rem; }

    /* CONTENT BLOCKS */
    .summary-box {
        background: var(--bg-surface);
        border: 1px solid #333;
        padding: 1rem;
        border-radius: 8px;
        font-size: 0.95rem;
        margin-bottom: 1.5rem;
    }
    .summary-box ul { padding-left: 1.2rem; list-style: square; color: var(--text-muted); }

    .definition {
        font-style: italic;
        color: var(--text-muted);
        border-left: 2px solid var(--accent);
        padding-left: 1rem;
        margin: 1.5rem 0;
    }

    .deep-dive { font-size: 1.05rem; color: #d0d0d0; text-align: justify; }
    .deep-dive p { margin-bottom: 1rem; }
    .deep-dive ul { padding-left: 1.5rem; margin-bottom: 1rem; color: #bbb; }
    .deep-dive li { margin-bottom: 0.5rem; }

    /* DIAGRAMS */
    .diagram-box {
        background: #000;
        border: 1px solid var(--border);
        padding: 1rem;
        margin: 2rem 0;
        overflow-x: auto;
        border-radius: 6px;
        position: relative;
    }
    .diagram-label { position: absolute; top: 5px; right: 10px; font-size: 0.7rem; color: #555; text-transform: uppercase; }
    pre {
        font-family: var(--font-mono);
        font-size: 13px;
        line-height: 1.3;
        color: var(--accent);
        white-space: pre;
    }

    .img-placeholder {
        background: #1a1a1a;
        border: 1px dashed #444;
        color: #666;
        padding: 2rem;
        text-align: center;
        margin: 1.5rem 0;
        font-size: 0.8rem;
        border-radius: 6px;
    }

    /* EXAM PARTS */
    .sample-answer {
        background: #0d0d0d;
        border: 1px solid #333;
        border-left: 4px solid var(--success);
        padding: 1.5rem;
        margin-top: 2rem;
        border-radius: 0 8px 8px 0;
    }
    
    .checklist { background: #0f1510; border: 1px solid #1b2e1e; padding: 1rem; margin-top: 1.5rem; border-radius: 8px; }
    .checklist h4 { color: var(--success); margin-bottom: 0.5rem; text-transform: uppercase; font-size: 0.8rem; }
    .checklist li { list-style: none; margin-bottom: 0.3rem; color: #bbb; }
    .checklist li::before { content: "✓ "; color: var(--success); font-weight: bold; }

    .mistakes { background: #1a1111; border: 1px solid #331a1a; padding: 1rem; margin-top: 1rem; border-radius: 8px; }
    .mistakes h4 { color: #ff5555; margin-bottom: 0.5rem; text-transform: uppercase; font-size: 0.8rem; }
    .mistakes li { list-style: none; margin-bottom: 0.3rem; color: #bbb; }
    .mistakes li::before { content: "⚠ "; color: #ff5555; }

    .cheat-sheet {
        border: 1px dashed var(--text-muted);
        padding: 1.5rem;
        margin-top: 2rem;
        border-radius: 8px;
    }
    .cheat-sheet h4 { text-align: center; margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 2px; }
    .cs-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; font-size: 0.85rem; }

    .practice-box { background: var(--bg-surface); border: 1px solid var(--border); padding: 1rem; margin-top: 2rem; border-radius: 8px; }

    /* FOOTER */
    footer { text-align: center; padding: 2rem; color: #444; font-size: 0.9rem; border-top: 1px solid #222; }

    /* MODES */
    body.mode-summary .deep-dive, body.mode-summary .sample-answer, body.mode-summary .checklist, body.mode-summary .mistakes, body.mode-summary .practice-box { display: none; }
    body.mode-diagram .deep-dive, body.mode-diagram .sample-answer, body.mode-diagram .checklist, body.mode-diagram .mistakes, body.mode-diagram .practice-box, body.mode-diagram .summary-box { display: none; }
    body.mode-revision .deep-dive, body.mode-revision .practice-box, body.mode-revision .sample-answer { display: none; } 

    /* PRINT */
    @media print {
        body { background: #fff; color: #000; }
        header, #sidebar, .action-btn { display: none; }
        .q-card { border-bottom: 1px solid #ccc; break-inside: avoid; }
        pre { color: #000; border: 1px solid #ccc; }
        .summary-box, .sample-answer, .checklist { background: #f5f5f5; color: #000; border: 1px solid #ddd; }
        h2, h3, strong { color: #000; }
    }
</style>
</head>
<body>

<header>
    <div class="logo">ArchNotes <span>Exam Prep</span></div>
    <button class="menu-toggle" onclick="toggleMenu()">☰ MENU</button>
</header>

<div id="sidebar">
    <button class="close-btn" onclick="toggleMenu()">×</button>
    
    <div class="menu-section">
        <h4>Search</h4>
        <input type="text" id="search-box" placeholder="Find question..." onkeyup="filterQuestions()">
    </div>

    <div class="menu-section">
        <h4>View Modes</h4>
        <div class="control-grid">
            <button class="action-btn active" onclick="setViewMode('all', this)">Full Study</button>
            <button class="action-btn" onclick="setViewMode('summary', this)">Summaries</button>
            <button class="action-btn" onclick="setViewMode('diagram', this)">Diagrams</button>
            <button class="action-btn" onclick="setViewMode('revision', this)">Revision</button>
        </div>
    </div>

    <div class="menu-section">
        <h4>Global Actions</h4>
        <div class="control-grid">
            <button class="action-btn" onclick="expandAll()">Expand All</button>
            <button class="action-btn" onclick="collapseAll()">Collapse All</button>
            <button class="action-btn" onclick="window.print()">Print / PDF</button>
        </div>
    </div>

    <div class="menu-section">
        <h4>Questions</h4>
        <div id="toc"></div>
    </div>
</div>

<main id="content">

    <!-- Q1 -->
    <section class="q-card" id="q1">
        <h2>Q1: Evolution of Software Architecture (Monolith to Distributed)</h2>
        
        <div class="summary-box">
            <strong>Quick Summary:</strong>
            <ul>
                <li>Evolution driven by <strong>scalability</strong> and <strong>agility</strong> needs.</li>
                <li>Mainframe (Monolith) -> PC (Client-Server) -> Web (SOA) -> Cloud (Microservices).</li>
                <li>Shift from <strong>Tight Coupling</strong> to <strong>Loose Coupling</strong>.</li>
                <li>Modern systems favor decentralization and fault tolerance.</li>
            </ul>
        </div>

        <div class="definition">
            <strong>Definition:</strong> The historical progression of software design paradigms, moving from single-unit <strong>Monolithic</strong> structures to decentralized <strong>Distributed Systems</strong>, aimed at solving complexity, deployment speed, and scaling challenges.
        </div>

        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p>The history of software architecture is fundamentally a story of managing complexity. In the early days of computing (1970s-80s), hardware was the constraint. Systems were built as <strong>Monoliths</strong>—huge, single executables running on mainframes. All layers (UI, Logic, Data) were tightly coupled in one codebase.</p>
            
            <p><strong>Why it changed:</strong> As user bases grew, Monoliths hit a wall. They suffered from the "Single Point of Failure" problem—one bug could crash the entire system. Scaling meant "Vertical Scaling" (buying bigger, more expensive servers), which has a physical limit.</p>

            <p><strong>The Client-Server Era (1990s):</strong> The rise of Personal Computers led to the first major split. The "Client" handled the presentation, and the "Server" handled the data. This 2-Tier (and later 3-Tier) architecture introduced the concept of <strong>logical separation</strong>.</p>

            <p><strong>SOA (2000s):</strong> With the internet, enterprises needed distinct systems (like Billing and Shipping) to talk to each other. <strong>Service Oriented Architecture (SOA)</strong> introduced the Enterprise Service Bus (ESB). It focused on reusability but was heavy and complex (XML/SOAP).</p>

            <p><strong>Microservices (2010s - Present):</strong> The Cloud era (AWS, Azure) demanded infinite scale. Applications are now broken into tiny, autonomous services. Each service has its own database and can be deployed independently. This enables <strong>Horizontal Scaling</strong> (adding more cheap servers) and allows teams to work in parallel using different technologies.</p>

            <p><strong>Trade-off:</strong> While distributed systems offer scale and resilience, they introduce massive <strong>complexity</strong> in networking, debugging, and data consistency (CAP theorem).</p>
        </div>

        <div class="diagram-box">
            <span class="diagram-label">ASCII Diagram</span>
<pre>
  [ 1980s ]      [ 1990s ]         [ 2000s ]         [ 2010s+ ]
 MONOLITH     CLIENT-SERVER          SOA           MICROSERVICES
 ________      ___________       ___________      ________________
|        |    |    UI     |     | Service A |    | [S1]   [S2]    |
| All-in |    |___________|     |___|___|___|    |  |      |      |
|  One   |          |             |  ESB  |      | (DB)   (DB)    |
|________|    |___DB______|     |_________|      |________________|
</pre>
        </div>

        <!-- Fallback for image if needed, keeping lightweight -->
        <!-- <div class="img-placeholder">Real Image Fallback: Evolution_Chart.png</div> -->

        <div class="sample-answer">
            <strong>Sample Answer (7 Marks)</strong>
            <p><strong>Definition:</strong> The evolution of software architecture represents the transition from centralized, rigid systems to decentralized, flexible distributed systems.</p>
            <p><strong>Key Phases:</strong>
            <br>1. <strong>Monolithic Architecture:</strong> The earliest phase where all modules (UI, Business Logic, Data) were bundled into a single artifact. It was simple to develop but suffered from tight coupling and vertical scaling limits.
            <br>2. <strong>Client-Server/Layered:</strong> Introduced logical separation (e.g., 3-Tier Architecture), decoupling the User Interface from the Database, improving maintainability.
            <br>3. <strong>Service-Oriented Architecture (SOA):</strong> Focused on enterprise integration using an ESB and SOAP, allowing large disparate systems to interoperate.
            <br>4. <strong>Microservices:</strong> The modern standard for cloud-native apps. It decomposes systems into small, autonomous services communicating via REST. This enables <strong>continuous deployment</strong> and infinite horizontal scaling.</p>
            <p><strong>Conclusion:</strong> The trend has consistently moved towards "Loose Coupling" to support the scale and speed of the modern web.</p>
        </div>

        <div class="checklist">
            <h4>7/7 Answer Checklist</h4>
            <ul>
                <li>Mention "Vertical Scaling" vs "Horizontal Scaling".</li>
                <li>Keyword: <strong>Coupling</strong> (Tight to Loose).</li>
                <li>Timeline: Mainframe -> PC -> Web -> Cloud.</li>
                <li>Draw the 4-stage diagram showing the breakdown.</li>
                <li>Mention "Single Point of Failure" for Monoliths.</li>
            </ul>
        </div>

        <div class="mistakes">
            <h4>Common Mistakes</h4>
            <ul>
                <li>Confusing SOA and Microservices (SOA uses ESB/SOAP, Microservices use REST/Smart Endpoints).</li>
                <li>Forgetting to mention the driver of change (Scale/Internet).</li>
            </ul>
        </div>

        <div class="cheat-sheet">
            <h4>Revision Cheat Sheet</h4>
            <div class="cs-grid">
                <div>
                    <strong>Mnemonic:</strong> M-C-S-M<br>
                    (Monolith, Client-Server, SOA, Microservices)
                </div>
                <div>
                    <strong>Key Trend:</strong><br>
                    Centralized DB -> Decentralized DB
                </div>
                <div>
                    <strong>Monolith:</strong><br>
                    Simple, Fast intra-call, Rigid.
                </div>
                <div>
                    <strong>Microservices:</strong><br>
                    Complex, Network latency, Agile.
                </div>
            </div>
        </div>
    </section>

    <!-- Q2 -->
    <section class="q-card" id="q2">
        <h2>Q2: Development Methodologies & Quality Model (ISO 9126)</h2>
        
        <div class="summary-box">
            <strong>Quick Summary:</strong>
            <ul>
                <li><strong>Waterfall:</strong> Linear, rigid, good for fixed requirements.</li>
                <li><strong>Agile:</strong> Iterative, flexible, good for changing markets.</li>
                <li><strong>ISO 9126:</strong> The international standard for software quality.</li>
                <li>Key Attributes: Functionality, Reliability, Usability, Efficiency.</li>
            </ul>
        </div>

        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Part 1: Methodologies</strong><br>
            How we build software matters as much as what we build.
            <br><strong>Waterfall Model:</strong> A classical linear approach. Like construction, you finish the "Design" phase completely before starting "Coding".
            <br>- <em>Pros:</em> Disciplined, easy to manage, clear milestones.
            <br>- <em>Cons:</em> <strong>"No turning back"</strong>. If a requirement changes late, the project fails.
            <br><strong>Agile Methodology (Scrum):</strong> An iterative approach. Software is built in small increments called <strong>Sprints</strong> (usually 2 weeks).
            <br>- <em>Pros:</em> Rapid feedback, adaptable to market changes.
            <br>- <em>Cons:</em> Scope creep, requires experienced developers.</p>

            <p><strong>Part 2: ISO 9126 Quality Model</strong><br>
            How do we define "Good" software? ISO 9126 provides a standard framework with 6 top-level characteristics:
            <br>1. <strong>Functionality:</strong> Suitability, Accuracy, Security. (Does it do the job?)
            <br>2. <strong>Reliability:</strong> Fault tolerance, Recoverability. (Does it stay up?)
            <br>3. <strong>Usability:</strong> Learnability, Operability. (Can humans use it?)
            <br>4. <strong>Efficiency:</strong> Time behavior, Resource utilization. (Is it fast?)
            <br>5. <strong>Maintainability:</strong> Testability, Changeability. (Is it easy to fix?)
            <br>6. <strong>Portability:</strong> Installability, Adaptability. (Can it move environments?)</p>
        </div>

        <div class="diagram-box">
            <span class="diagram-label">Methodology Diagram</span>
<pre>
  WATERFALL (Linear)          AGILE (Iterative)
 [ Reqs ]                    (    Plan    )
    |                      /            \
 [ Design ]              ( Deploy      Code )
    |                      \            /
 [ Code ]                    (    Test    )
    |                         ------------
 [ Test ]                    (Repeats Loop)
</pre>
        </div>

        <div class="sample-answer">
            <strong>Sample Answer (7 Marks)</strong>
            <p><strong>Software Development Methodologies:</strong>
            <br>1. <strong>Waterfall:</strong> A sequential design process where progress flows steadily downwards. Each phase (Reqs, Design, Code, Test) must complete before the next begins. It is rigid and best for stable requirements.
            <br>2. <strong>Agile:</strong> An iterative approach focusing on rapid delivery of small software increments. It values customer collaboration and responsiveness to change over following a strict plan.</p>
            <p><strong>Software Quality Model (ISO 9126):</strong>
            <br>To objectively measure quality, ISO 9126 defines six characteristics:
            <br>- <strong>Functionality:</strong> Does it provide the required functions?
            <br>- <strong>Reliability:</strong> Can it maintain performance under conditions?
            <br>- <strong>Usability:</strong> Effort needed to learn and use.
            <br>- <strong>Efficiency:</strong> Performance relative to resources.
            <br>- <strong>Maintainability:</strong> Effort needed to modify.
            <br>- <strong>Portability:</strong> Ability to transfer environments.</p>
        </div>

        <div class="cheat-sheet">
            <h4>Revision Cheat Sheet</h4>
            <div class="cs-grid">
                <div>
                    <strong>Mnemonic:</strong> F-R-U-E-M-P<br>
                    (Func, Rel, Use, Eff, Maint, Port)
                </div>
                <div>
                    <strong>Waterfall:</strong><br>
                    Document-driven, Rigid.
                </div>
                <div>
                    <strong>Agile:</strong><br>
                    Feedback-driven, Flexible.
                </div>
            </div>
        </div>
    </section>

    <!-- Q3 -->
    <section class="q-card" id="q3">
        <h2>Q3: Architecture Business Cycle (ABC)</h2>
        
        <div class="summary-box">
            <strong>Quick Summary:</strong>
            <ul>
                <li>Architecture is not created in a vacuum.</li>
                <li><strong>Inputs:</strong> Stakeholders, Organization, Technical Environment.</li>
                <li><strong>Output:</strong> System.</li>
                <li><strong>Feedback:</strong> The system changes the environment that created it.</li>
            </ul>
        </div>

        <div class="definition">
            <strong>Definition:</strong> The Architecture Business Cycle (ABC) is the concept that software architecture is a result of technical, business, and social influences, and the resulting system reciprocally influences those factors.
        </div>

        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p>The architect does not design in isolation. They are "in the middle" of a cycle.</p>
            <p><strong>1. Influences on the Architect (Inputs):</strong>
            <br>- <strong>Stakeholders:</strong> Users want features, managers want low cost, testers want observability. These goals conflict. The architect must trade them off.
            <br>- <strong>Developing Organization:</strong> <strong>Conway's Law</strong> states that "Systems mirror the communication structure of the organization." If you have 3 disconnected teams, you will likely build a system with 3 disconnected parts.
            <br>- <strong>Technical Environment:</strong> The tools, frameworks, and standards available at the time (e.g., "We must use AI because it's trending") force design choices.
            <br>- <strong>Architect's Experience:</strong> We stick to what we know. A Java architect will likely propose a Java solution.</p>

            <p><strong>2. The Feedback Loop (Return Cycle):</strong>
            <br>Once the system is built and deployed, it changes the world:
            <br>- <strong>Organization:</strong> The team acquires new skills (e.g., "Now we are experts in React").
            <br>- <strong>Stakeholders:</strong> Seeing the system generates NEW requirements ("I didn't know I wanted this until I saw it").
            <br>- <strong>Tech Env:</strong> A successful system might become a platform or standard for others.</p>
        </div>

        <div class="diagram-box">
            <span class="diagram-label">ABC Diagram</span>
<pre>
  [Stakeholders]   [Organization]   [Tech Env]
        |                |               |
        | (Reqs)         | (Skills)      | (Tools)
        v                v               v
     _________________________________________
    |           THE ARCHITECT                 |
    |_________________________________________|
                     |
                     v
              [ ARCHITECTURE ]
                     |
                     v
                [ SYSTEM ]
               /     |    \
(Feedback)    v      v     v
    [Stakeholders] [Org] [Tech Env]
</pre>
        </div>

        <div class="checklist">
            <h4>7/7 Answer Checklist</h4>
            <ul>
                <li>Draw the Architect in the center.</li>
                <li>Label inputs: Stakeholders, Org, Tech Env, Experience.</li>
                <li>Label outputs: Architecture -> System.</li>
                <li>Draw the Feedback loop arrows back to the top.</li>
                <li>Mention <strong>Conway's Law</strong>.</li>
            </ul>
        </div>
    </section>

    <!-- Q4 -->
    <section class="q-card" id="q4">
        <h2>Q4: Software Quality Models (McCall, Boehm, FURPS)</h2>
        
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p>Different eras produced different ways to categorize "Quality".</p>
            <p><strong>1. McCall’s Model (1977):</strong> Organized around three perspectives of the product lifecycle.
            <br>- <strong>Product Revision:</strong> Can I change it? (Maintainability, Flexibility, Testability).
            <br>- <strong>Product Transition:</strong> Can I move it? (Portability, Reusability, Interoperability).
            <br>- <strong>Product Operation:</strong> Does it run well? (Correctness, Reliability, Efficiency, Integrity, Usability).</p>

            <p><strong>2. Boehm’s Model (1978):</strong> A hierarchical model focusing on "General Utility".
            <br>- <strong>Key Difference:</strong> It explicitly places <strong>Maintainability</strong> as a primary driver of utility. Boehm argued that if software costs too much to maintain, its utility is low, regardless of how fast it runs.</p>

            <p><strong>3. FURPS Model (HP):</strong> A simplified, functional industry model.
            <br>- <strong>F</strong>unctionality: Features, Capabilities.
            <br>- <strong>U</strong>sability: Human factors, Aesthetics.
            <br>- <strong>R</strong>eliability: Frequency of failure, Recoverability.
            <br>- <strong>P</strong>erformance: Speed, Throughput, Response time.
            <br>- <strong>S</strong>upportability: Testability, Extensibility, Serviceability.</p>
        </div>

        <div class="sample-answer">
            <strong>Sample Answer (7 Marks)</strong>
            <p><strong>1. McCall’s Model:</strong> Classifies quality into three dimensions regarding the product's lifecycle:
            <br>- <strong>Product Operation:</strong> (Correctness, Efficiency, Reliability)
            <br>- <strong>Product Revision:</strong> (Maintainability, Flexibility, Testability)
            <br>- <strong>Product Transition:</strong> (Portability, Reusability)
            <br><strong>2. Boehm’s Model:</strong> A hierarchical model that prioritizes <strong>Maintainability</strong> as a key factor for "General Utility", suggesting that hard-to-maintain software has low value.
            <br><strong>3. FURPS Model:</strong> An acronym developed by HP:
            <br>- <strong>F</strong>unctionality
            <br>- <strong>U</strong>sability
            <br>- <strong>R</strong>eliability
            <br>- <strong>P</strong>erformance
            <br>- <strong>S</strong>upportability</p>
        </div>
        
        <div class="cheat-sheet">
            <h4>Revision Cheat Sheet</h4>
            <div class="cs-grid">
                <div><strong>McCall:</strong><br>Op, Rev, Trans.</div>
                <div><strong>Boehm:</strong><br>Utility hierarchy.</div>
                <div><strong>FURPS:</strong><br>F-U-R-P-S.</div>
            </div>
        </div>
    </section>

    <!-- Q5 -->
    <section class="q-card" id="q5">
        <h2>Q5: Architectural Models (Views)</h2>
        
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p>Architecture is too complex to view from just one angle. We use different "Views" or models to describe it to different stakeholders.</p>
            
            <p><strong>1. Structural Model (The Skeleton):</strong>
            <br>Describes the static organization of the system.
            <br>- <em>Focus:</em> "What is it made of?"
            <br>- <em>Elements:</em> Classes, Objects, Modules, Servers.
            <br>- <em>Diagrams:</em> Class Diagrams, Component Diagrams.
            <br>- <em>Audience:</em> Developers.</p>

            <p><strong>2. Dynamic Model (The Blood Flow):</strong>
            <br>Describes the runtime behavior.
            <br>- <em>Focus:</em> "What happens when I click this?"
            <br>- <em>Elements:</em> State transitions, Message passing, Data flow.
            <br>- <em>Diagrams:</em> Sequence Diagrams, State Charts.
            <br>- <em>Audience:</em> Testers and Developers (debugging).</p>

            <p><strong>3. Process Model (The Construction):</strong>
            <br>Describes the steps to build and run the system.
            <br>- <em>Focus:</em> "Who does what?"
            <br>- <em>Elements:</em> IDEs, Build scripts, CI/CD pipelines, Concurrency.
            <br>- <em>Audience:</em> Project Managers, DevOps.</p>

            <p><strong>4. Framework Model (The Pattern):</strong>
            <br>Describes the high-level architectural style or reference architecture used.
            <br>- <em>Focus:</em> "What rules do we follow?"
            <br>- <em>Examples:</em> "This is an MVC app", "This is a Pipe-and-Filter system".</p>
        </div>
        
        <div class="checklist">
            <h4>7/7 Answer Checklist</h4>
            <ul>
                <li>List Structural, Dynamic, Process, Framework.</li>
                <li>Give a 1-line definition for each.</li>
                <li>Mention "Static" for Structural and "Runtime" for Dynamic.</li>
                <li>Mention "CI/CD" or "Builds" for Process.</li>
            </ul>
        </div>
    </section>

    <!-- Q6 -->
    <section class="q-card" id="q6">
        <h2>Q6: Architectural Styles: Data-Flow, Pipe & Filter, Call & Return</h2>
        
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>1. Data-Flow Architecture:</strong>
            <br>In this style, the entire structure is determined by the motion of data. Components are "workers" that wait for input data, transform it, and output it. There is <strong>no global state</strong>. The system is purely reactive to data availability.</p>

            <p><strong>2. Pipes and Filters (Subtype of Data-Flow):</strong>
            <br>- <strong>Filters:</strong> Independent processing units. They read a stream, process it incrementally, and write to output. Crucially, Filter A <strong>does not know</strong> Filter B exists.
            <br>- <strong>Pipes:</strong> Connectors that buffer and carry data.
            <br>- <em>Example:</em> UNIX Shell (`cat file | grep "err" | sort`).
            <br>- <em>Pros:</em> High Reusability (mix & match filters), Concurrency.
            <br>- <em>Cons:</em> Performance overhead (parsing/unparsing data between filters).</p>

            <p><strong>3. Call-and-Return Architecture:</strong>
            <br>The dominant style in classical programming (C, Java).
            <br>- <strong>Main-Subroutine:</strong> A main controller explicitly calls sub-routines. The caller waits for the callee to finish.
            <br>- <strong>Object-Oriented:</strong> Objects encapsulate data and call methods on each other.
            <br>- <em>Pros:</em> Easy to reason about (sequential flow).
            <br>- <em>Cons:</em> Tightly coupled components. Hard to distribute across a network.</p>
        </div>

        <div class="diagram-box">
<pre>
PIPE & FILTER:
 [Source] -> (Pipe) -> [Filter A] -> (Pipe) -> [Filter B] -> [Sink]

CALL & RETURN:
      [ Main Program ]
      /      |       \
   (Call)  (Call)   (Call)
    /        |         \
 [Sub A]   [Sub B]    [Sub C]
    \________|_________/
         (Returns)
</pre>
        </div>
    </section>

    <!-- Q7 -->
    <section class="q-card" id="q7">
        <h2>Q7: Constraints of RESTful API</h2>
        
        <div class="summary-box">
            <strong>Quick Summary:</strong>
            <ul>
                <li>REST is defined by <strong>6 Constraints</strong> (Roy Fielding).</li>
                <li>It is resource-based, not action-based.</li>
                <li><strong>Statelessness</strong> is the most critical constraint for scaling.</li>
            </ul>
        </div>

        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p>REST (Representational State Transfer) is often misunderstood as just "using JSON over HTTP". To be truly RESTful, an architecture must adhere to 6 constraints:</p>
            <ol>
                <li><strong>Client-Server:</strong> Strict separation of concerns. Server stores data; Client handles UI. They evolve independently.</li>
                <li><strong>Stateless:</strong> The server contains <strong>NO client state</strong>. Each request must contain all information (e.g., Auth Token) necessary to understand it. The server does not remember "User X is logged in". This allows any server to handle any request.</li>
                <li><strong>Cacheable:</strong> Responses must explicitly label themselves as cacheable or non-cacheable to improve client performance.</li>
                <li><strong>Uniform Interface:</strong> The core constraint.
                    <ul>
                        <li>Resource Identification (URIs like `/users/1`).</li>
                        <li>Standard Methods (GET, POST, PUT, DELETE).</li>
                        <li><strong>HATEOAS</strong> (Hypermedia as Engine of Application State) - API returns links to next possible actions.</li>
                    </ul>
                </li>
                <li><strong>Layered System:</strong> The client cannot tell if it is connected directly to the end server or an intermediary (Load Balancer, CDN).</li>
                <li><strong>Code on Demand (Optional):</strong> The server can extend client functionality by sending executable code (e.g., JavaScript).</li>
            </ol>
        </div>

        <div class="cheat-sheet">
            <h4>Mnemonic: S-C-U-L-C-S</h4>
            <div class="cs-grid">
                <div><strong>S</strong>tateless</div>
                <div><strong>C</strong>lient-Server</div>
                <div><strong>U</strong>niform Interface</div>
                <div><strong>L</strong>ayered System</div>
                <div><strong>C</strong>acheable</div>
                <div><strong>S</strong>cript (Code on Demand)</div>
            </div>
        </div>
    </section>

    <!-- Q8 -->
    <section class="q-card" id="q8">
        <h2>Q8: Layered vs Data-Centered Architecture</h2>
        
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>1. Layered Architecture:</strong>
            <br>Organizes the system into horizontal layers of abstraction.
            <br>- <strong>Rule:</strong> Layer N provides services to Layer N+1. Layer N+1 only calls Layer N (Strict layering).
            <br>- <strong>Layers:</strong> Presentation (UI) -> Business Logic -> Data Access (DAO) -> Database.
            <br>- <em>Pros:</em> Separation of concerns, Testability (mock layers), Easy to swap layers (e.g., change DB without touching UI).
            <br>- <em>Cons:</em> <strong>"Sinkhole antipattern"</strong> (requests passing through layers that do nothing but pass data), Latency.</p>

            <p><strong>2. Data-Centered (Repository) Architecture:</strong>
            <br>A central data store is the primary means of communication.
            <br>- <strong>Structure:</strong> A Central Repository (Database) surrounded by independent Clients.
            <br>- <em>Passive Repository:</em> Clients pull/push data (e.g., Standard DB apps).
            <br>- <em>Active Blackboard:</em> Repository notifies clients when data changes (e.g., AI systems, IDEs like Eclipse).
            <br>- <em>Pros:</em> Data integrity is centralized. Clients are decoupled from each other.
            <br>- <em>Cons:</em> Repository is a <strong>Single Point of Failure</strong> and performance bottleneck.</p>
        </div>

        <div class="diagram-box">
<pre>
A. LAYERED:                  B. DATA-CENTERED:
_____________________          [Client A]  [Client B]
| Presentation (UI) |               \        /
|___________________|                v      v
         | v                       [REPOSITORY]
_____________________              [ DATABASE ]
| Business Logic    |                ^      ^
|___________________|               /        \
         | v                   [Client C]  [Client D]
_____________________
| Data Access (DAO) |
|___________________|
</pre>
        </div>
    </section>

    <!-- Q9 -->
    <section class="q-card" id="q9">
        <h2>Q9: Microservices: Benefits & Challenges</h2>

        <div class="summary-box">
            <strong>Quick Summary:</strong>
            <ul>
                <li>Small, autonomous services.</li>
                <li><strong>Database per Service</strong> pattern.</li>
                <li>Benefit: Infinite Scale, Agility.</li>
                <li>Challenge: Complexity, Data Consistency.</li>
            </ul>
        </div>

        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> An architectural style where an application is a collection of small, autonomous services, each running in its own process, communicating via lightweight mechanisms (HTTP/REST), and independently deployable.</p>

            <p><strong>Core Principles:</strong>
            <br>- <strong>Database per Service:</strong> No shared big database. Each service owns its data.
            <br>- <strong>Smart Endpoints, Dumb Pipes:</strong> Logic is in the service, not the bus (unlike SOA).
            <br>- <strong>Decentralized Governance:</strong> Teams choose their own tools (Polyglot persistence).</p>

            <p><strong>Benefits:</strong>
            <br>1. <strong>Agility:</strong> Small teams can work in parallel. Faster time-to-market.
            <br>2. <strong>Flexible Scaling:</strong> Scale only the "Search" service during high traffic, not the "Login" service.
            <br>3. <strong>Technology Heterogeneity:</strong> Use Python for AI service, Java for Banking service.
            <br>4. <strong>Fault Isolation:</strong> If one service crashes, the rest of the app survives.</p>

            <p><strong>Challenges:</strong>
            <br>1. <strong>Distributed Complexity:</strong> Network latency, debugging is hard (Requires Distributed Tracing).
            <br>2. <strong>Data Consistency:</strong> No ACID transactions across services. Must use "Eventual Consistency" (Sagas).
            <br>3. <strong>Operational Overhead:</strong> Requires complex DevOps (Docker, Kubernetes).</p>
        </div>

        <div class="cheat-sheet">
            <h4>Mnemonic: S-I-D</h4>
            <div class="cs-grid">
                <div><strong>S</strong>mall</div>
                <div><strong>I</strong>ndependent</div>
                <div><strong>D</strong>istributed</div>
            </div>
        </div>
    </section>

    <!-- Q10 -->
    <section class="q-card" id="q10">
        <h2>Q10: Agent-based & Reactive Architecture</h2>
        
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Part 1: Agent-Based Architecture</strong>
            <br>Composed of "Agents"—autonomous components that perceive their environment and act to achieve goals.
            <br>- <strong>Characteristics:</strong>
                <ul>
                    <li><strong>Autonomy:</strong> Acts without direct intervention.</li>
                    <li><strong>Reactivity:</strong> Perceives environment changes.</li>
                    <li><strong>Social Ability:</strong> Negotiates/Collaborates with other agents.</li>
                </ul>
            <br>- <em>Use Cases:</em> Robotics, Stock trading bots, Traffic control systems.</p>

            <p><strong>Part 2: Reactive Architecture (The Reactive Manifesto)</strong>
            <br>Systems designed to be robust in the modern cloud/mobile era. Defined by 4 traits:
            <br>1. <strong>Responsive:</strong> Responds in a timely manner (Low latency).
            <br>2. <strong>Resilient:</strong> Stays responsive even when failures occur (Fault tolerance).
            <br>3. <strong>Elastic:</strong> Stays responsive under varying workload (Auto-scaling).
            <br>4. <strong>Message Driven:</strong> Uses asynchronous message passing to ensure loose coupling (The Foundation).</p>
        </div>
        
        <div class="cheat-sheet">
            <h4>Mnemonic: R-R-E-M</h4>
            <div class="cs-grid">
                <div>Responsive</div>
                <div>Resilient</div>
                <div>Elastic</div>
                <div>Message-Driven</div>
            </div>
        </div>
    </section>

    <!-- Q11 -->
    <section class="q-card" id="q11">
        <h2>Q11: Event-Driven Architecture (EDA)</h2>
        
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> A pattern where components communicate by emitting <strong>Events</strong> (facts that happened, e.g., "UserClickedBuy") rather than direct calls. Consumers listen for events and react.</p>
            <p><strong>Key Concepts:</strong>
            <br>- <strong>Decoupling:</strong> The producer does not know who is listening. It just yells "Order Placed!" and moves on.
            <br>- <strong>Asynchronous:</strong> Non-blocking. The producer doesn't wait for the consumer.
            <br>- <strong>Broker Topology:</strong> A central Event Bus (like Kafka/RabbitMQ) manages the flow.</p>
            <p><strong>Pros:</strong> High scalability, easy to add new features (just add a new listener).
            <br><strong>Cons:</strong> Hard to trace execution flow (no linear stack trace). "What triggered this?" is hard to answer.</p>
        </div>

        <div class="diagram-box">
<pre>
 [ Producer ] ---> (Event: "OrderPlaced")
                         |
                   [ EVENT BROKER ]
                   /      |       \
            (Push)     (Push)     (Push)
             /            |           \
      [Email Svc]    [Stock Svc]   [Log Svc]
</pre>
        </div>
    </section>

    <!-- Q12 -->
    <section class="q-card" id="q12">
        <h2>Q12: Architecture Description Languages (ADLs)</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> ADLs are formal languages used to describe software architecture precisely, focusing on components and connectors (unlike programming languages which focus on algorithms).</p>
            
            <p><strong>Essential Features of an ADL:</strong>
            <br>1. <strong>Components:</strong> Defines units of computation (e.g., database, server).
            <br>2. <strong>Connectors:</strong> Defines interactions (e.g., pipes, SQL link).
            <br>3. <strong>Configuration:</strong> Defines the topology/graph.
            <br>4. <strong>Tool Support:</strong> Allows analysis (deadlock detection) and code generation.</p>

            <p><strong>Types/Examples:</strong>
            <br>- <strong>ACME:</strong> A generic interchange language to swap data between tools.
            <br>- <strong>Wright:</strong> Focuses on formal analysis of deadlocks and protocols.
            <br>- <strong>Darwin:</strong> Focuses on distributed systems and dynamic structures.</p>
        </div>
    </section>

    <!-- Q13 -->
    <section class="q-card" id="q13">
        <h2>Q13: CORBA & Java RMI</h2>
        
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>1. CORBA (Common Object Request Broker Architecture):</strong>
            <br>- <strong>Goal:</strong> Language Independence. A C++ object calls a Java object.
            <br>- <strong>Mechanism:</strong> Uses an <strong>ORB</strong> (Object Request Broker) as a middleware bus. Interfaces are defined in <strong>IDL</strong> (Interface Definition Language).
            <br>- <em>Use Case:</em> Legacy banking systems mixing Cobol mainframes with C++ clients.</p>

            <p><strong>2. Java RMI (Remote Method Invocation):</strong>
            <br>- <strong>Goal:</strong> Java-to-Java communication.
            <br>- <strong>Mechanism:</strong> Uses Stubs (Client-side proxy) and Skeletons (Server-side helper). It uses Java Serialization to send objects over the wire.
            <br>- <em>Use Case:</em> Pure Java enterprise applications (EJB) in the early 2000s.</p>

            <p><strong>Comparison:</strong> CORBA is complex but universal. RMI is simple but Java-only.</p>
        </div>

        <div class="diagram-box">
<pre>
 [ Client Object ]        [ Server Object ]
        |                        ^
     (Stub)                  (Skeleton)
        |________________________|
             NETWORK / ORB
</pre>
        </div>
    </section>

    <!-- Q14 -->
    <section class="q-card" id="q14">
        <h2>Q14: Model View Architecture (MVC)</h2>
        
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> MVC (Model-View-Controller) is a pattern to separate internal representation of information from the way it is presented to the user.</p>
            
            <p><strong>Components:</strong>
            <br>1. <strong>Model:</strong> The Brain. Contains data, state, and business logic. It is <strong>independent</strong> of the UI. It notifies the View when data changes.
            <br>2. <strong>View:</strong> The Face. Displays data to the user. It observes the Model.
            <br>3. <strong>Controller:</strong> The Coordinator. Handles user input (clicks, keys), updates the Model, and selects the View.</p>

            <p><strong>Web MVC Variant:</strong>
            <br>Controller (Server) receives request -> Updates DB (Model) -> Selects HTML Template (View) -> Returns to Browser.</p>
        </div>

        <div class="diagram-box">
<pre>
     User Input
         |
         v
   [ CONTROLLER ] -----------> [ MODEL ]
   (Logic/Handler)            (Data/State)
         |                         |
    Selects View              Updates View
         |                         |
         v                         v
     [ VIEW ] <--------------------|
    (Display UI)
</pre>
        </div>
    </section>

    <!-- Q15 -->
    <section class="q-card" id="q15">
        <h2>Q15: Role of UML</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> UML (Unified Modeling Language) is the standard visual language for specifying, visualizing, constructing, and documenting the artifacts of software systems.</p>

            <p><strong>Roles:</strong>
            <br>1. <strong>Visualization:</strong> "A picture is worth 1000 lines of code." It helps stakeholders understand complex flows.
            <br>2. <strong>Specification:</strong> It defines precise interfaces and behaviors before coding starts.
            <br>3. <strong>Blueprint for Construction:</strong> CASE tools can generate code skeletons from UML diagrams.
            <br>4. <strong>Documentation:</strong> It serves as a permanent record for maintenance teams.</p>

            <p><strong>Key Diagrams for Architects:</strong>
            <br>- <strong>Class Diagram:</strong> Static structure.
            <br>- <strong>Sequence Diagram:</strong> Runtime interaction/timing.
            <br>- <strong>Deployment Diagram:</strong> Physical hardware mapping.</p>
        </div>
    </section>

    <!-- Q16 -->
    <section class="q-card" id="q16">
        <h2>Q16: JSP & Servlet Lifecycle</h2>
        
        <div class="summary-box">
            <strong>Quick Summary:</strong>
            <ul>
                <li>JSP = HTML + Java.</li>
                <li>Servlet = Java class handling HTTP.</li>
                <li>Lifecycle: Load -> Init -> Service -> Destroy.</li>
            </ul>
        </div>

        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>1. JSP (JavaServer Pages):</strong>
            <br>A technology for developing web pages that support dynamic content. It allows inserting Java code in HTML using tags (`<% code %>`).
            <br>- <em>How it works:</em> The server translates the JSP into a Servlet (Java code) automatically upon the first request.</p>

            <p><strong>2. Servlet Lifecycle:</strong>
            <br>Servlets are managed by a Web Container (e.g., Tomcat). The lifecycle has 4 phases:</p>
            <ol>
                <li><strong>Loading & Instantiation:</strong> The container loads the class and creates an instance.</li>
                <li><strong>init():</strong> Called <strong>ONCE</strong>. Used for one-time setup (e.g., DB connection).</li>
                <li><strong>service():</strong> Called for <strong>EVERY</strong> request. It runs in a separate thread and dispatches to `doGet()` or `doPost()`.</li>
                <li><strong>destroy():</strong> Called <strong>ONCE</strong> when the server shuts down. Used to release resources.</li>
            </ol>
        </div>

        <div class="cheat-sheet">
            <h4>Mnemonic: L-I-S-D</h4>
            <div class="cs-grid">
                <div>Load</div>
                <div>Init</div>
                <div>Service</div>
                <div>Destroy</div>
            </div>
        </div>
    </section>

    <!-- Q17 -->
    <section class="q-card" id="q17">
        <h2>Q17: Cost Benefit Analysis (CBAM)</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> CBAM is an economic modeling method used to decide <strong>which</strong> architectural strategies should be implemented given a budget. It adds "Cost" and "ROI" to the technical analysis.</p>

            <p><strong>The Steps:</strong>
            <br>1. <strong>Collate Scenarios:</strong> Gather feature requests/scenarios.
            <br>2. <strong>Refine Scenarios:</strong> Pick the top ones based on business goals.
            <br>3. <strong>Prioritize Scenarios:</strong> Stakeholders vote (allocate 100 points).
            <br>4. <strong>Assign Utility:</strong> How much "benefit" does this scenario provide?
            <br>5. <strong>Develop Strategies:</strong> What architectural change is needed for this?
            <br>6. <strong>Determine Cost:</strong> How much money/time to build it?
            <br>7. <strong>Calculate ROI:</strong> (Benefit / Cost). Rank strategies by ROI and select top ones until budget runs out.</p>
        </div>
    </section>

    <!-- Q18 -->
    <section class="q-card" id="q18">
        <h2>Q18: Attribute Driven Design (ADD)</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> ADD is a recursive design method where the architecture is generated by prioritizing <strong>Quality Attributes</strong> (Performance, Security) rather than just functional requirements.</p>

            <p><strong>The Recursive Process:</strong>
            <br>1. <strong>Choose a Module</strong> to design.
            <br>2. <strong>Identify Drivers:</strong> Pick the high-priority quality attributes (e.g., "Must handle 10k users").
            <br>3. <strong>Choose a Pattern:</strong> Select an architectural tactic that satisfies the driver (e.g., "Use Load Balancer").
            <br>4. <strong>Instantiate:</strong> Apply the pattern.
            <br>5. <strong>Decompose:</strong> Break down the module and repeat step 1 for sub-modules.</p>
        </div>
    </section>

    <!-- Q19 -->
    <section class="q-card" id="q19">
        <h2>Q19: ATAM (Tradeoff Analysis)</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> ATAM is a method to evaluate an architecture <strong>before</strong> coding begins to identify risks.</p>

            <p><strong>Phases:</strong>
            <br>1. <strong>Presentation:</strong> Architect presents the design; Stakeholders present business goals.
            <br>2. <strong>Investigation:</strong> Generate a "Utility Tree" (prioritized quality goals).
            <br>3. <strong>Testing:</strong> Brainstorm scenarios (e.g., "What if the DB fails?"). Walk through the design to see if it holds up.
            <br>4. <strong>Reporting:</strong> Present the findings.</p>

            <p><strong>Key Outputs (R-N-S-T):</strong>
            <br>- <strong>Risks:</strong> Decisions that might hurt quality.
            <br>- <strong>Non-Risks:</strong> Good decisions.
            <br>- <strong>Sensitivity Points:</strong> A component where a small change causes a big impact (e.g., "Encryption level heavily affects latency").
            <br>- <strong>Trade-off Points:</strong> Decisions that improve one attribute but hurt another (e.g., "Compression saves storage but hurts speed").</p>
        </div>
    </section>

    <!-- Q20 -->
    <section class="q-card" id="q20">
        <h2>Q20: ARID (Active Reviews)</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> ARID is a review method for <strong>partial</strong> designs or subsystems (unlike ATAM which is for the whole system). It checks if the design is actually usable by the developers.</p>

            <p><strong>How it works:</strong>
            <br>1. It is a hybrid of a <strong>Design Review</strong> and a <strong>Code Walkthrough</strong>.
            <br>2. <strong>Reviewers:</strong> The developers who will use the design (e.g., who will consume the API).
            <br>3. <strong>Process:</strong> Present a scenario. Ask the reviewers to write pseudo-code using the design to solve it.
            <br>4. <strong>Pass/Fail:</strong> If the developers struggle to use the interface, the design fails.</p>
        </div>
    </section>

    <!-- Q21 -->
    <section class="q-card" id="q21">
        <h2>Q21: Refinement & Documentation</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Part 1: Refinement</strong>
            <br>Refinement is the gradual process of converting high-level abstract specifications into low-level executable code.
            <br><em>Chain:</em> Conceptual Arch -> Logical Design -> Physical Design -> Code.</p>

            <p><strong>Part 2: Principles of Sound Documentation</strong>
            <br>1. <strong>Write for the Reader:</strong> Identify who is reading (Manager vs Coder) and write for them.
            <br>2. <strong>Avoid Repetition:</strong> Maintain a "Single Source of Truth".
            <br>3. <strong>Record Rationale:</strong> Document <strong>WHY</strong> a decision was made, not just WHAT was made. This helps future maintainers.
            <br>4. <strong>Keep it Current:</strong> Outdated documentation is worse than no documentation.
            <br>5. <strong>Standardize:</strong> Use standard templates (Views and Viewpoints).</p>
        </div>
    </section>

    <!-- Q22 -->
    <section class="q-card" id="q22">
        <h2>Q22: 7-Part Doc Template</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p>When documenting a specific View (e.g., Component View), use this standard template:</p>
            <ol>
                <li><strong>Primary Presentation:</strong> The main diagram (e.g., the UML Class diagram).</li>
                <li><strong>Element Catalog:</strong> A dictionary describing every box/line in the diagram.</li>
                <li><strong>Context Diagram:</strong> Shows how this part fits into the larger system.</li>
                <li><strong>Variability Guide:</strong> Explains what is configurable or changeable.</li>
                <li><strong>Architecture Background:</strong> Rationale, analysis, and why choices were made.</li>
                <li><strong>Glossary:</strong> Definitions of terms used.</li>
                <li><strong>Other Info:</strong> Authors, dates, version history.</li>
            </ol>
        </div>
        <div class="cheat-sheet">
            <h4>Mnemonic: P-E-C-V-A-G-O</h4>
        </div>
    </section>

    <!-- Q23 -->
    <section class="q-card" id="q23">
        <h2>Q23: Architecture Interfaces</h2>
        <div class="deep-dive">
            <h3>Deep Explanation</h3>
            <p><strong>Definition:</strong> An <strong>Interface</strong> is a boundary across which two components exchange information. It defines a contract: "What I do" vs "How I do it".</p>

            <p><strong>Types:</strong>
            <br>1. <strong>Provided Interface (Lollipop):</strong> Services a component offers to others. (e.g., `API.getUser()`).
            <br>2. <strong>Required Interface (Socket):</strong> Services a component needs to function. (e.g., `Needs DatabaseConnection`).</p>

            <p><strong>Importance:</strong>
            <br>- Allows <strong>Parallel Development</strong> (Team A builds client, Team B builds server).
            <br>- Allows <strong>Modifiability</strong> (You can rewrite the internals as long as the interface stays the same).</p>
            
            <p><strong>Example:</strong> A REST API Swagger file is an architectural interface definition.</p>
        </div>
    </section>

</main>

<footer>
    <p>Made by Maverick – 2025</p>
    <p style="color:#666; font-size:0.8rem; margin-top:0.5rem;">Exam Study Resource | RGPV 7th Sem</p>
</footer>

<script>
    // Sidebar Logic
    function toggleMenu() {
        document.getElementById('sidebar').classList.toggle('active');
    }

    // TOC Generation
    document.addEventListener('DOMContentLoaded', () => {
        const toc = document.getElementById('toc');
        document.querySelectorAll('h2').forEach(h2 => {
            const id = h2.parentElement.id;
            const title = h2.innerText.split(':')[0];
            const link = document.createElement('a');
            link.href = '#' + id;
            link.className = 'toc-link';
            link.innerText = title;
            link.onclick = toggleMenu;
            toc.appendChild(link);
        });
    });

    // View Modes
    function setViewMode(mode, btn) {
        document.body.className = 'mode-' + mode;
        document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        toggleMenu();
    }

    // Expand/Collapse
    function expandAll() {
        document.querySelectorAll('.deep-dive, .sample-answer').forEach(el => el.style.display = 'block');
        toggleMenu();
    }
    function collapseAll() {
        document.querySelectorAll('.deep-dive, .sample-answer').forEach(el => el.style.display = 'none');
        toggleMenu();
    }

    // Search
    function filterQuestions() {
        const term = document.getElementById('search-box').value.toLowerCase();
        document.querySelectorAll('.q-card').forEach(card => {
            const text = card.innerText.toLowerCase();
            card.style.display = text.includes(term) ? 'block' : 'none';
        });
    }
</script>

</body>
</html>
